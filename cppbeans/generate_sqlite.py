import json
import sys
import re
from collections import defaultdict

from genbeans.common import sql_order

BODY="""// This file is an AUTOGENERATED part of beans project.
// Copyright (c) 2017 Aleksander Gajewski <adiog@quicksave.io>.

#pragma once

#include <SQLiteCpp/SQLiteCpp.h>
#include <CppBeans.h>
#include <string>
#include <iostream>
#include <qs/util/format.h>
#include <qs/util/hash.h>
#include <qs/database/SqliteTransaction.h>
#include <qsgen/bean/___BEAN___Bean.h>

___INC___

template<typename DB, typename T>
class DatabaseBean;

using DB = SQLite::Database;

template<>
class DatabaseBean<DB, ___BEAN___Bean>
{
public:
    static absl::optional<___BEAN___Bean> get(DB* sqliteDatabase, std::string hash)
    {
        try
        {
            SQLite::Statement query(*sqliteDatabase, "SELECT * FROM ___TABLE___ WHERE ___PK___ = ?");

            query.bind(1, hash);

            while (query.executeStep())
            {
                ___BEAN___Bean bean;

                int getIndex = 0;
                ___RETRIEVE___
                return bean;
            }
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
            return absl::nullopt;
        }
    }

    template<typename FIELD_VALUE>
    static List<___BEAN___Bean> get_by(DB* sqliteDatabase, std::string field, FIELD_VALUE field_value)
    {
        List<___BEAN___Bean> result(0);

        try
        {
            std::string query_str = Format::format("SELECT * FROM ___TABLE___ WHERE %s = ?", field.c_str());
            SQLite::Statement query(*sqliteDatabase, query_str.c_str());

            query.bind(1, field_value);

            while (query.executeStep())
            {
                ___BEAN___Bean bean;

                int getIndex = 0;
                ___RETRIEVE___
                result.push_back(bean);
            }
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
            return result;
        }

        return result;
    }

    static void remove(DB* sqliteDatabase, std::string hash)
    {
        try
        {
            SQLite::Statement query(*sqliteDatabase, "DELETE FROM ___TABLE___ WHERE ___PK___ = ?");

            query.bind(1, hash);

            query.exec();
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
        }
    }

    template<typename FIELD_VALUE>
    static void remove_by(DB* sqliteDatabase, std::string field, FIELD_VALUE field_value)
    {
        try
        {
            std::string query_str = Format::format("DELETE FROM ___TABLE___ WHERE %s = ?", field.c_str());
            SQLite::Statement query(*sqliteDatabase, query_str.c_str());

            query.bind(1, field_value);

            query.exec();
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
        }

    }

    static List<___BEAN___Bean> sql(DB* sqliteDatabase, std::string sql)
    {
        List<___BEAN___Bean> result(0);

        try
        {
            SQLite::Statement query(*sqliteDatabase, sql.c_str());

            while (query.executeStep())
            {
                ___BEAN___Bean bean;
                int getIndex = 0;

                ___RETRIEVE___
                result.push_back(bean);
            }
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
            return result;
        }

        return result;
    }

    static std::string insert(DB* sqliteDatabase, ___BEAN___Bean bean)
    {
        try
        {
            SQLite::Statement query(*sqliteDatabase, "INSERT INTO ___TABLE___ (___FIELDS___) VALUES (___BIND_MARK___)");

            int bindIndex = 1;
            ___GET_HASH___
            ___BIND_ALL___
            query.exec();

            return *bean.___BEAN_HASH___;
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
        }
    }

    static void insert_with_pk(DB* sqliteDatabase, ___BEAN___Bean bean)
    {
        try
        {
            SQLite::Statement query(*sqliteDatabase, "INSERT INTO ___TABLE___ (___FIELDS___) VALUES (___BIND_PK_MARK___)");

            int bindIndex = 1;
            ___BIND_ALL___
            query.exec();
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
        }
    }

    static void update(DB* sqliteDatabase, ___BEAN___Bean bean)
    {
        try
        {
            std::string setBuilder = "";
            ___UPDATE_SET_BUILDER___
            std::string query_template = Format::format("UPDATE ___TABLE___ SET %s WHERE ___PK___ = ?", setBuilder.c_str());
            SQLite::Statement query(*sqliteDatabase, query_template.c_str());

            int bindIndex = 1;
            ___BIND_UPDATE___
            ___BIND_PK___

            query.exec();
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
        }
    }

    static void override(DB* sqliteDatabase, ___BEAN___Bean bean)
    {
        try
        {
            SQLite::Statement query(*sqliteDatabase, "UPDATE ___TABLE___ SET ___SET_OVERRIDE___ WHERE ___PK___ = ?");

            int bindIndex = 1;
        
            ___BIND___
            ___BIND_PK___

            query.exec();
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
        }
    }
};

"""


atoms = ["Int", "String", "List"]

def split_to_list(label, type_list):
    if re.match(r'^[A-Za-z0-9]+$', label):
        type_list.append(label)
        return type_list
    else:
        try:
            a_type = re.search(r'(\w+).*', label).group(1)
        except:
            raise RuntimeError('Unknown atom in "%s" of expected form "atom(...)"' % label)
        try:
            remaining_label = re.search(r'\((.*)\)', label).group(1)
        except:
            raise RuntimeError('Unknown atom in "%s" of expected form "...(atom)"' % label)
        type_list.append(a_type)
        return split_to_list(remaining_label, type_list)


cpp_dict = {
    "Int": "int",
    "String": "std::string",
    "Bool": "bool",
    "Base64": "Base64",
    "SerializedDict": "SerializedDict",
    "List": "List"
}

sqlite_api = {
    "Int": 'Int',
    "String": 'String',
    "SerializedDict": 'String'
}

sqlite_api_suffix = defaultdict(str)

def make_bean(bean_path, bean_filename):
    sqlite_api_suffix['SerializedDict'] = '.c_str()'
    bean_name = bean_filename[:-5]
    bean_name_lower = bean_name.lower()

    bean_json = json.load(open(bean_path + '/' + bean_filename, 'r'))
    bean_pk, other_fields = sql_order(bean_name_lower, bean_json)
    if not bean_pk is None:
        fields = [bean_pk] + other_fields
    else:
        fields = other_fields
    bind_stmt = ''
    bind_update_stmt = ''
    bind_all_stmt = ''
    retrieve_stmt = ''
    set_stmt = []
    set_builder_stmt = []
    bind_placeholder = []
    bind_with_pk_placeholder = []
    to_be_included = set()

    bind_index = 1
    for i, bean_key in enumerate(fields):
        l = split_to_list(bean_json[bean_key], [])

        is_optional = l[0] == 'Optional'
        if l[0] == 'Optional':
            l = l[1:]

        if bean_pk == bean_key:
            bind_placeholder.append('?')
            get_hash = 'if (!bean.%s) bean.%s = qs::util::Hash::get();' % (bean_key, bean_key)
        else:
            bind_placeholder.append('?')
            if is_optional:
                set_builder_stmt.append('if (bean.%s) {setBuilder += ((setBuilder != "") ? std::string(", ") : std::string("")) + std::string("%s = ?");}' % (bean_key, bean_key))
            else:
                set_builder_stmt.append('setBuilder += ((setBuilder != "") ? std::string(", ") : std::string("")) + std::string("%s = ?");' % (bean_key))
        bind_with_pk_placeholder.append('?')

        set_stmt.append('%s = ?' % bean_key)


        cpp_type = ''
        for t in reversed(l):
            if t not in cpp_dict:
                to_be_included.add(t)
            t = cpp_dict.get(t, t+'Bean')
            if cpp_type != '':
                cpp_type = '%s<%s>' % (t, cpp_type)
            else:
                cpp_type = t

        if is_optional:
            cpp_opt_type = 'absl::optional<%s>' % cpp_type
        else:
            cpp_opt_type = cpp_type

        if is_optional:
            if bean_pk != bean_key:
                bind_update_stmt += 'if (bean.%s) query.bind(bindIndex++, *bean.%s);\n' % (bean_key, bean_key)
                bind_stmt += 'if (bean.%s) query.bind(bindIndex++, *bean.%s); else query.bind(bindIndex++);\n' % (bean_key, bean_key)
            bind_all_stmt += 'if (bean.%s) query.bind(bindIndex++, *bean.%s); else query.bind(bindIndex++);\n' % (bean_key, bean_key)
            retrieve_stmt += 'bean.%s = absl::make_optional<%s>(query.getColumn(getIndex++).get%s());\n' % (bean_key, cpp_type, sqlite_api[l[-1]])
        else:
            if bean_pk != bean_key:
                bind_stmt += 'query.bind(bindIndex++, bean.%s);\n' % (bean_key)
                bind_update_stmt += 'query.bind(bindIndex++, bean.%s);\n' % (bean_key)
            bind_all_stmt += 'query.bind(bindIndex++, bean.%s);\n' % (bean_key)
            retrieve_stmt += 'bean.%s = query.getColumn(getIndex++).get%s()%s;\n' % (bean_key, sqlite_api[l[-1]], sqlite_api_suffix[l[-1]])

    if 'Optional' in bean_json[bean_pk]:
        bind_pk_stmt = 'query.bind(bindIndex++, *bean.%s);' % (bean_pk)
    else:
        bind_pk_stmt = 'query.bind(bindIndex++, bean.%s);' % (bean_pk)

#    print('-------query.bind(%s, *bean.%s);' % (len(bean_json), bean_pk))

    include_stmt = ''
    for inc in to_be_included:
        include_stmt += '#include <qsgen/bean/%sBean.h>\n' % inc
    print(
        re.sub('___GUARD___', bean_name.upper() + '_DB_H',
        re.sub('___PK___', bean_pk,
        re.sub('___GET_HASH___', get_hash,
        re.sub('___BEAN___', bean_name,
        re.sub('___BEAN_HASH___', bean_pk,
        re.sub('___BIND___', bind_stmt,
        re.sub('___BIND_UPDATE___', ''.join(bind_update_stmt),
        re.sub('___BIND_ALL___', bind_all_stmt,
        re.sub('___BIND_PK___', bind_pk_stmt,
        re.sub('___BIND_MARK___', ', '.join(bind_placeholder),
        re.sub('___BIND_PK_MARK___', ', '.join(bind_with_pk_placeholder),
        re.sub('___RETRIEVE___', retrieve_stmt,
        re.sub('___TABLE___', bean_name_lower,
        re.sub('___FIELDS___', ', '.join(['\'' + field + '\'' for field in fields]),
        re.sub('___INC___', include_stmt,
        re.sub('___UPDATE_SET_BUILDER___', ''.join(set_builder_stmt),
        re.sub('___SET_OVERRIDE___', ', '.join(set_stmt),
                 BODY))))))))))))))))))

if __name__ == '__main__':
    make_bean(bean_path=sys.argv[1], bean_filename=sys.argv[2])
