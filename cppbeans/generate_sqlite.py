import json
import sys
import re

from genbeans.common import sql_order

BODY="""// This file is an AUTOGENERATED part of beans project.
// Copyright (c) 2017 Aleksander Gajewski <adiog@quicksave.io>.

#ifndef ___GUARD___
#define ___GUARD___

#include <SQLiteCpp/SQLiteCpp.h>
#include <CppBeans.h>
#include <string>
#include <iostream>
#include <util/format.h>
___INC___

template<typename T>
class DatabaseBean;

template<>
class DatabaseBean<___BEAN___Bean>
{
public:
    template<typename DB>
    static std::optional<___BEAN___Bean> get(DB* db, int id)
    {
        try
        {
            SQLite::Statement query(*db, "SELECT * FROM ___TABLE___ WHERE ___PK___ = ?");

            query.bind(1, id);

            while (query.executeStep())
            {
                ___BEAN___Bean bean;

                ___RETRIEVE___
                return bean;
            }
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
            return std::none;
        }
    }

    template<typename DB, typename FIELD_VALUE>
    static List<___BEAN___Bean> get_by(DB* db, std::string field, FIELD_VALUE field_value)
    {
        List<___BEAN___Bean> result(0);

        try
        {
            std::string query_str = Format::format("SELECT * FROM ___TABLE___ WHERE %s = ?", field);
            SQLite::Statement query(*db, query_str.c_str());

            query.bind(1, field_value);

            while (query.executeStep())
            {
                ___BEAN___Bean bean;

                ___RETRIEVE___
                result.push_back(bean);
            }
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
            return result;
        }

        return result;
    }

    template<typename DB>
    static void remove(DB* db, int id)
    {
        try
        {
            SQLite::Statement query(*db, "DELETE FROM ___TABLE___ WHERE ___PK___ = ?");

            query.bind(1, id);

            query.exec();
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
        }
    }

    template<typename DB, typename FIELD_VALUE>
    static void remove_by(DB* db, std::string field, FIELD_VALUE field_value)
    {
        try
        {
            std::string query_str = Format::format("DELETE FROM ___TABLE___ WHERE %s = ?", field);
            SQLite::Statement query(*db, query_str.c_str());

            query.bind(1, field_value);

            query.exec();
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
        }

    }

    template<typename DB>
    static List<___BEAN___Bean> sql(DB* db, std::string sql)
    {
        List<___BEAN___Bean> result(0);

        try
        {
            SQLite::Statement query(*db, sql.c_str());

            while (query.executeStep())
            {
                ___BEAN___Bean bean;

                ___RETRIEVE___
                result.push_back(bean);
            }
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
            return result;
        }

        return result;
    }

    template<typename DB>
    static int insert(DB* db, ___BEAN___Bean bean)
    {
        try
        {
            SQLite::Statement query(*db, "INSERT INTO ___TABLE___ (___FIELDS___) VALUES (___BIND_MARK___)");

            ___BIND___
            query.exec();

            return db->getLastInsertRowid();
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
        }
    }

    template<typename DB>
    static void insert_with_pk(DB* db, ___BEAN___Bean bean)
    {
        try
        {
            SQLite::Statement query(*db, "INSERT INTO ___TABLE___ (___FIELDS___) VALUES (___BIND_PK_MARK___)");

            ___BIND_ALL___
            query.exec();
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
        }
    }

    template<typename DB>
    static void update(DB* db, ___BEAN___Bean bean)
    {
        try
        {
            SQLite::Statement query(*db, "UPDATE ___TABLE___ SET ___SET___ WHERE ___PK___ = ?");

            ___BIND___
            ___BIND_PK___

            query.exec();
        }
        catch (std::exception& e)
        {
            std::cout << "exception: " << e.what() << std::endl;
        }
    }
};

#endif
"""


atoms = ["Int", "String", "List"]

def split_to_list(label, type_list):
    if re.match(r'^[A-Za-z0-9]+$', label):
        type_list.append(label)
        return type_list
    else:
        try:
            a_type = re.search(r'(\w+).*', label).group(1)
        except:
            raise RuntimeError('Unknown atom in "%s" of expected form "atom(...)"' % label)
        try:
            remaining_label = re.search(r'\((.*)\)', label).group(1)
        except:
            raise RuntimeError('Unknown atom in "%s" of expected form "...(atom)"' % label)
        type_list.append(a_type)
        return split_to_list(remaining_label, type_list)


cpp_dict = {
    "Int": "int",
    "String": "std::string",
    "Bool": "bool",
    "Base64": "Base64",
    "List": "List"
}

sqlite_api = {
    "Int": 'getInt()'
}

def make_bean(bean_path, bean_filename):
    bean_name = bean_filename[:-5]
    bean_name_lower = bean_name.lower()

    bean_json = json.load(open(bean_path + '/' + bean_filename, 'r'))
    bean_pk, other_fields = sql_order(bean_name_lower, bean_json)
    fields = [bean_pk] + other_fields
    bind_stmt = ''
    bind_all_stmt = ''
    retrieve_stmt = ''
    set_stmt = []
    bind_placeholder = []
    bind_with_pk_placeholder = []
    to_be_included = set()

    bind_index = 1
    for i, bean_key in enumerate(fields):
        l = split_to_list(bean_json[bean_key], [])

        if bean_pk == bean_key:
            bind_placeholder.append('NULL')
        else:
            bind_placeholder.append('?')
            set_stmt.append('%s = ?' % bean_key)
        bind_with_pk_placeholder.append('?')

        is_optional = l[0] == 'Optional'
        if l[0] == 'Optional':
            l = l[1:]

        cpp_type = ''
        for t in reversed(l):
            if t not in cpp_dict:
                to_be_included.add(t)
            t = cpp_dict.get(t, t+'Bean')
            if cpp_type != '':
                cpp_type = '%s<%s>' % (t, cpp_type)
            else:
                cpp_type = t

        if is_optional:
            cpp_opt_type = 'std::optional<%s>' % cpp_type
        else:
            cpp_opt_type = cpp_type

        if is_optional:
            if bean_pk != bean_key:
                bind_stmt += 'if (bean.%s) query.bind(%s, *bean.%s); else query.bind(%s, "NULL");\n' % (bean_key, bind_index, bean_key, bind_index)
                bind_index += 1
            bind_all_stmt += 'if (bean.%s) query.bind(%s, *bean.%s); else query.bind(%s, "NULL");\n' % (bean_key, i+1, bean_key, bind_index)
            retrieve_stmt += 'bean.%s = std::make_optional<%s>(query.getColumn(%s).get%s());\n' % (bean_key, cpp_type, i, l[-1])
        else:
            if bean_pk != bean_key:
                bind_stmt += 'query.bind(%s, bean.%s);\n' % (bind_index, bean_key)
                bind_index += 1
            bind_all_stmt += 'query.bind(%s, bean.%s);\n' % (i+1, bean_key)
            retrieve_stmt += 'bean.%s = query.getColumn(%s).get%s();\n' % (bean_key, i, l[-1])

    if 'Optional' in bean_json[bean_pk]:
        bind_pk_stmt = 'query.bind(%s, *bean.%s);' % (len(bean_json), bean_pk)
    else:
        bind_pk_stmt = 'query.bind(%s, bean.%s);' % (len(bean_json), bean_pk)

#    print('-------query.bind(%s, *bean.%s);' % (len(bean_json), bean_pk))

    include_stmt = ''
    for inc in to_be_included:
        include_stmt += '#include <bean/%sBean.h>\n' % inc
    print(
        re.sub('___GUARD___', bean_name.upper() + '_DB_H',
        re.sub('___PK___', bean_pk,
        re.sub('___BEAN___', bean_name,
        re.sub('___BIND___', bind_stmt,
        re.sub('___BIND_ALL___', bind_all_stmt,
        re.sub('___BIND_PK___', bind_pk_stmt,
        re.sub('___BIND_MARK___', ', '.join(bind_placeholder),
        re.sub('___BIND_PK_MARK___', ', '.join(bind_with_pk_placeholder),
        re.sub('___RETRIEVE___', retrieve_stmt,
        re.sub('___TABLE___', bean_name_lower,
        re.sub('___FIELDS___', ', '.join(fields),
        re.sub('___INC___', include_stmt,
        re.sub('___SET___', ', '.join(set_stmt),
                 BODY))))))))))))))

if __name__ == '__main__':
    make_bean(bean_path=sys.argv[1], bean_filename=sys.argv[2])
