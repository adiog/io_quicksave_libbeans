// This file is an AUTOGENERATED part of beans project.
// Copyright (c) 2017 Aleksander Gajewski <adiog@quicksave.io>.

#pragma once

#include <CppBeans.h>
#include <SQLiteCpp/SQLiteCpp.h>
#include <database/PostgresTransaction.h>
#include <hash>
#include <iostream>
#include <string>
#include <util/format.h>

template <typename T> class DatabaseBean;

template <> class DatabaseBean<UserBean> {
public:
  template <typename DB>
  static std::optional<UserBean> get(DB *db, std::string hash) {
    try {
      tao::postgres::transaction *tr =
          dynamic_cast<database::PostgresTransaction *>(db)->get();
      const char *query = "SELECT * FROM public.user WHERE user_hash = $1";

      auto result = tr->execute(query, hash);
      auto row = result[0];

      UserBean bean;

      int getIndex = 0;

      bean.user_hash =
          std::make_optional<std::string>(row.get<std::string>(getIndex++));
      bean.databaseConnectionString = row.get<std::string>(getIndex++);
      bean.password = row.get<std::string>(getIndex++);
      bean.storageConnectionString = row.get<std::string>(getIndex++);
      bean.username = row.get<std::string>(getIndex++);

      return bean;
    } catch (std::exception &e) {
      std::cout << "exception: " << e.what() << std::endl;
      return std::none;
    }
  }

  template <typename DB, typename FIELD_VALUE>
  static List<UserBean> get_by(DB *db, std::string field,
                               FIELD_VALUE field_value) {
    List<UserBean> result(0);

    try {
      tao::postgres::transaction *tr =
          dynamic_cast<database::PostgresTransaction *>(db)->get();
      std::string query_str = Format::format(
          "SELECT * FROM public.user WHERE %s = $1", field.c_str());
      const char *query = query_str.c_str();

      auto query_result = tr->execute(query, field_value);

      for (int rowIndex = 0; rowIndex < query_result.size(); ++rowIndex) {
        auto row = query_result.at(rowIndex);

        UserBean bean;

        int getIndex = 0;

        bean.user_hash =
            std::make_optional<std::string>(row.get<std::string>(getIndex++));
        bean.databaseConnectionString = row.get<std::string>(getIndex++);
        bean.password = row.get<std::string>(getIndex++);
        bean.storageConnectionString = row.get<std::string>(getIndex++);
        bean.username = row.get<std::string>(getIndex++);

        result.push_back(bean);
      }
    } catch (std::exception &e) {
      std::cout << "exception: " << e.what() << std::endl;
      return result;
    }

    return result;
  }

  template <typename DB> static void remove(DB *db, std::string hash) {
    try {
      tao::postgres::transaction *tr =
          dynamic_cast<database::PostgresTransaction *>(db)->get();
      const char *query = "DELETE FROM public.user WHERE user_hash = $1";

      tr->execute(query, hash);
    } catch (std::exception &e) {
      std::cout << "exception: " << e.what() << std::endl;
    }
  }

  template <typename DB, typename FIELD_VALUE>
  static void remove_by(DB *db, std::string field, FIELD_VALUE field_value) {
    try {
      tao::postgres::transaction *tr =
          dynamic_cast<database::PostgresTransaction *>(db)->get();
      std::string query_str = Format::format(
          "DELETE FROM public.user WHERE %s = $1", field.c_str());
      const char *query = query_str.c_str();

      tr->execute(query, field_value);
    } catch (std::exception &e) {
      std::cout << "exception: " << e.what() << std::endl;
    }
  }

  template <typename DB> static List<UserBean> sql(DB *db, std::string sql) {
    List<UserBean> result(0);

    try {
      tao::postgres::transaction *tr =
          dynamic_cast<database::PostgresTransaction *>(db)->get();
      const char *query = sql.c_str();

      auto query_result = tr->execute(query);

      for (int rowIndex = 0; rowIndex < query_result.size(); ++rowIndex) {
        auto row = query_result.at(rowIndex);

        UserBean bean;

        int getIndex = 0;

        bean.user_hash =
            std::make_optional<std::string>(row.get<std::string>(getIndex++));
        bean.databaseConnectionString = row.get<std::string>(getIndex++);
        bean.password = row.get<std::string>(getIndex++);
        bean.storageConnectionString = row.get<std::string>(getIndex++);
        bean.username = row.get<std::string>(getIndex++);

        result.push_back(bean);
      }
    } catch (std::exception &e) {
      std::cout << "exception: " << e.what() << std::endl;
      return result;
    }

    return result;
  }

  template <typename DB> static std::string insert(DB *db, UserBean bean) {
    try {
      tao::postgres::transaction *tr =
          dynamic_cast<database::PostgresTransaction *>(db)->get();
      const char *query = "INSERT INTO public.user (\"user_hash\", "
                          "\"databaseConnectionString\", \"password\", "
                          "\"storageConnectionString\", \"username\") VALUES "
                          "($1, $2, $3, $4, $5)";

      int bindIndex = 1;
      if (!bean.user_hash)
        bean.user_hash = Hash::get();

      tr->execute(query, *bean.user_hash, bean.databaseConnectionString,
                  bean.password, bean.storageConnectionString, bean.username);

      return *bean.user_hash;
    } catch (std::exception &e) {
      std::cout << "exception: " << e.what() << std::endl;
    }
  }

  template <typename DB> static void insert_with_pk(DB *db, UserBean bean) {
    try {
      tao::postgres::transaction *tr =
          dynamic_cast<database::PostgresTransaction *>(db)->get();
      const char *query = "INSERT INTO public.user (\"user_hash\", "
                          "\"databaseConnectionString\", \"password\", "
                          "\"storageConnectionString\", \"username\") VALUES "
                          "($1, $2, $3, $4, $5)";

      tr->execute(query, *bean.user_hash, bean.databaseConnectionString,
                  bean.password, bean.storageConnectionString, bean.username);

    } catch (std::exception &e) {
      std::cout << "exception: " << e.what() << std::endl;
    }
  }

  template <typename DB> static void update(DB *db, UserBean bean) {
    try {
      tao::postgres::transaction *tr =
          dynamic_cast<database::PostgresTransaction *>(db)->get();
      std::string setBuilder = "";
      setBuilder +=
          ((setBuilder != "") ? std::string(", ") : std::string("")) +
          Format::format(std::string("\"databaseConnectionString\" = '%s'"),
                         bean.databaseConnectionString.c_str());
      setBuilder += ((setBuilder != "") ? std::string(", ") : std::string("")) +
                    Format::format(std::string("\"password\" = '%s'"),
                                   bean.password.c_str());
      setBuilder +=
          ((setBuilder != "") ? std::string(", ") : std::string("")) +
          Format::format(std::string("\"storageConnectionString\" = '%s'"),
                         bean.storageConnectionString.c_str());
      setBuilder += ((setBuilder != "") ? std::string(", ") : std::string("")) +
                    Format::format(std::string("\"username\" = '%s'"),
                                   bean.username.c_str());
      std::string query_template = Format::format(
          "UPDATE public.user SET %s WHERE user_hash = $1", setBuilder.c_str());
      const char *query = query_template.c_str();

      tr->execute(query, *bean.user_hash);
    } catch (std::exception &e) {
      std::cout << "exception: " << e.what() << std::endl;
    }
  }
  /*
      template<typename DB>
      static void override(DB* db, UserBean bean)
      {
          try
          {
              tao::postgres::transaction *sqliteDatabase =
  dynamic_cast<database::SqliteTransaction*>(db)->get(); const char * query =
  "UPDATE public.user SET user_hash = $1, databaseConnectionString = $2,
  password = $3, storageConnectionString = $4, username = $5 WHERE user_hash =
  ?";

              int bindIndex = 1;

              query.bind(bindIndex++, bean.databaseConnectionString);
  query.bind(bindIndex++, bean.password);
  query.bind(bindIndex++, bean.storageConnectionString);
  query.bind(bindIndex++, bean.username);

              query.bind(bindIndex++, *bean.user_hash);

              query.exec();
          }
          catch (std::exception& e)
          {
              std::cout << "exception: " << e.what() << std::endl;
          }
      }*/
};
