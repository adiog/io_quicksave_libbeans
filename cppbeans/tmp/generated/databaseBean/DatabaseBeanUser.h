// This file is an AUTOGENERATED part of beans project.
// Copyright (c) 2017 Aleksander Gajewski <adiog@quicksave.io>.

#pragma once

#include <CppBeans.h>
#include <SQLiteCpp/SQLiteCpp.h>
#include <database/PostgresTransaction.h>
#include <hash>
#include <iostream>
#include <string>
#include <util/format.h>

template <typename T> class DatabaseBean;

template <> class DatabaseBean<UserBean> {
public:
  template <typename DB>
  static std::optional<UserBean> get(DB *db, std::string hash) {
    try {
      tao::postgres::transaction *tr =
          dynamic_cast<tao::postgres::transaction *>(db)->get();
      const char query = "SELECT * FROM user WHERE user_hash = $1";

      auto result = tr->execute(query, hash);
      auto row = result[0];

      UserBean bean;

      int getIndex = 0;

      bean.user_hash =
          std::make_optional<std::string>(row[getIndex++].as<String>());
      bean.databaseConnectionString = row[getIndex++].as<String>();
      bean.password = row[getIndex++].as<String>();
      bean.storageConnectionString = row[getIndex++].as<String>();
      bean.username = row[getIndex++].as<String>();

      return bean;
    } catch (std::exception &e) {
      std::cout << "exception: " << e.what() << std::endl;
      return std::none;
    }
  }
  /*
      template<typename DB, typename FIELD_VALUE>
      static List<UserBean> get_by(DB* db, std::string field, FIELD_VALUE
  field_value)
      {
          List<UserBean> result(0);

          try
          {
              tao::postgres::transaction *sqliteDatabase =
  dynamic_cast<database::SqliteTransaction*>(db)->get(); std::string query_str =
  Format::format("SELECT * FROM user WHERE %s = ?", field.c_str()); const char *
  query = query_str.c_str();

              auto result = tr->execute(query, field_value);

              while (query.executeStep())
              {
                  UserBean bean;

                  int getIndex = 0;
                  bean.user_hash =
  std::make_optional<std::string>(row[getIndex++].as<String>());
  bean.databaseConnectionString = row[getIndex++].as<String>();
  bean.password = row[getIndex++].as<String>();
  bean.storageConnectionString = row[getIndex++].as<String>();
  bean.username = row[getIndex++].as<String>();

                  result.push_back(bean);
              }
          }
          catch (std::exception& e)
          {
              std::cout << "exception: " << e.what() << std::endl;
              return result;
          }

          return result;
      }

      template<typename DB>
      static void remove(DB* db, std::string hash)
      {
          try
          {
              tao::postgres::transaction *sqliteDatabase =
  dynamic_cast<database::SqliteTransaction*>(db)->get(); SQLite::Statement
  query(*sqliteDatabase, "DELETE FROM user WHERE user_hash = ?");

              query.bind(1, hash);

              query.exec();
          }
          catch (std::exception& e)
          {
              std::cout << "exception: " << e.what() << std::endl;
          }
      }

      template<typename DB, typename FIELD_VALUE>
      static void remove_by(DB* db, std::string field, FIELD_VALUE field_value)
      {
          try
          {
              tao::postgres::transaction *sqliteDatabase =
  dynamic_cast<database::SqliteTransaction*>(db)->get(); std::string query_str =
  Format::format("DELETE FROM user WHERE %s = ?", field.c_str());
              SQLite::Statement query(*sqliteDatabase, query_str.c_str());

              query.bind(1, field_value);

              query.exec();
          }
          catch (std::exception& e)
          {
              std::cout << "exception: " << e.what() << std::endl;
          }

      }

      template<typename DB>
      static List<UserBean> sql(DB* db, std::string sql)
      {
          List<UserBean> result(0);

          try
          {
              tao::postgres::transaction *sqliteDatabase =
  dynamic_cast<database::SqliteTransaction*>(db)->get(); SQLite::Statement
  query(*sqliteDatabase, sql.c_str());

              while (query.executeStep())
              {
                  UserBean bean;
                  int getIndex = 0;

                  bean.user_hash =
  std::make_optional<std::string>(row[getIndex++].as<String>());
  bean.databaseConnectionString = row[getIndex++].as<String>();
  bean.password = row[getIndex++].as<String>();
  bean.storageConnectionString = row[getIndex++].as<String>();
  bean.username = row[getIndex++].as<String>();

                  result.push_back(bean);
              }
          }
          catch (std::exception& e)
          {
              std::cout << "exception: " << e.what() << std::endl;
              return result;
          }

          return result;
      }

      template<typename DB>
      static std::string insert(DB* db, UserBean bean)
      {
          try
          {
              tao::postgres::transaction *sqliteDatabase =
  dynamic_cast<database::SqliteTransaction*>(db)->get(); SQLite::Statement
  query(*sqliteDatabase, "INSERT INTO user ('user_hash',
  'databaseConnectionString', 'password', 'storageConnectionString', 'username')
  VALUES (?, ?, ?, ?, ?)");

              int bindIndex = 1;
              if (!bean.user_hash) bean.user_hash = Hash::get();
              if (bean.user_hash) query.bind(bindIndex++, *bean.user_hash); else
  query.bind(bindIndex++); query.bind(bindIndex++,
  bean.databaseConnectionString); query.bind(bindIndex++, bean.password);
  query.bind(bindIndex++, bean.storageConnectionString);
  query.bind(bindIndex++, bean.username);

              query.exec();

              return *bean.user_hash;
          }
          catch (std::exception& e)
          {
              std::cout << "exception: " << e.what() << std::endl;
          }
      }

      template<typename DB>
      static void insert_with_pk(DB* db, UserBean bean)
      {
          try
          {
              tao::postgres::transaction *sqliteDatabase =
  dynamic_cast<database::SqliteTransaction*>(db)->get(); SQLite::Statement
  query(*sqliteDatabase, "INSERT INTO user ('user_hash',
  'databaseConnectionString', 'password', 'storageConnectionString', 'username')
  VALUES (?, ?, ?, ?, ?)");

              int bindIndex = 1;
              if (bean.user_hash) query.bind(bindIndex++, *bean.user_hash); else
  query.bind(bindIndex++); query.bind(bindIndex++,
  bean.databaseConnectionString); query.bind(bindIndex++, bean.password);
  query.bind(bindIndex++, bean.storageConnectionString);
  query.bind(bindIndex++, bean.username);

              query.exec();
          }
          catch (std::exception& e)
          {
              std::cout << "exception: " << e.what() << std::endl;
          }
      }

      template<typename DB>
      static void update(DB* db, UserBean bean)
      {
          try
          {
              tao::postgres::transaction *sqliteDatabase =
  dynamic_cast<database::SqliteTransaction*>(db)->get(); std::string setBuilder
  = ""; setBuilder += ((setBuilder != "") ? std::string(", ") : std::string(""))
  + std::string("databaseConnectionString = ?");setBuilder += ((setBuilder !=
  "") ? std::string(", ") : std::string("")) + std::string("password =
  ?");setBuilder += ((setBuilder != "") ? std::string(", ") : std::string("")) +
  std::string("storageConnectionString = ?");setBuilder += ((setBuilder != "") ?
  std::string(", ") : std::string("")) + std::string("username = ?");
              std::string query_template = Format::format("UPDATE user SET %s
  WHERE user_hash = ?", setBuilder.c_str()); SQLite::Statement
  query(*sqliteDatabase, query_template.c_str());

              int bindIndex = 1;
              query.bind(bindIndex++, bean.databaseConnectionString);
  query.bind(bindIndex++, bean.password);
  query.bind(bindIndex++, bean.storageConnectionString);
  query.bind(bindIndex++, bean.username);

              query.bind(bindIndex++, *bean.user_hash);

              query.exec();
          }
          catch (std::exception& e)
          {
              std::cout << "exception: " << e.what() << std::endl;
          }
      }

      template<typename DB>
      static void override(DB* db, UserBean bean)
      {
          try
          {
              tao::postgres::transaction *sqliteDatabase =
  dynamic_cast<database::SqliteTransaction*>(db)->get(); const char * query =
  "UPDATE user SET user_hash = ?, databaseConnectionString = ?, password = ?,
  storageConnectionString = ?, username = ? WHERE user_hash = ?";

              int bindIndex = 1;

              query.bind(bindIndex++, bean.databaseConnectionString);
  query.bind(bindIndex++, bean.password);
  query.bind(bindIndex++, bean.storageConnectionString);
  query.bind(bindIndex++, bean.username);

              query.bind(bindIndex++, *bean.user_hash);

              query.exec();
          }
          catch (std::exception& e)
          {
              std::cout << "exception: " << e.what() << std::endl;
          }
      }*/
};
